<!DOCTYPE html>
<html lang="ja" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body class="m-0 p-0 font-sans antialiased bg-black text-white">
    <div id="app" class="min-h-screen">
        <div v-if="currentView === 'menu'" class="min-h-screen flex items-center justify-center bg-black">
            <input type="file" accept="application/pdf" @change="handleFileChange">
        </div>
        <div v-if="currentView === 'pdf'" class="min-h-screen bg-black">
            <button @click="closePdf"
                class="fixed top-4 right-4 z-50 bg-transparent backdrop-blur-sm hover:bg-black/20 text-white py-1 px-2 rounded-full shadow-lg hover:scale-110 transition-all flex items-center">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <div class="w-full h-screen overflow-y-auto">
                <div ref="pdfContainer" class="flex flex-col items-center gap-2 py-4"></div>
            </div>
        </div>
    </div>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const { createApp, ref, onUnmounted } = Vue;
        createApp({
            setup() {
                const currentView = ref('menu');
                const pdfUrl = ref(null);
                const pdfContainer = ref(null);
                const currentPdf = ref(null);

                const revokeUrl = () => {
                    if (pdfUrl.value) {
                        URL.revokeObjectURL(pdfUrl.value);
                        pdfUrl.value = null;
                    }
                };

                const closePdf = () => {
                    if (pdfContainer.value) {
                        pdfContainer.value.innerHTML = '';
                    }
                    currentPdf.value = null;
                    revokeUrl();
                    currentView.value = 'menu';
                };

                const renderPdf = async (url) => {
                    try {
                        const pdf = await pdfjsLib.getDocument(url).promise;
                        currentPdf.value = pdf;
                        const container = pdfContainer.value;
                        container.innerHTML = '';

                        const baseScale = 1.0;
                        const pixelRatio = Math.min(window.devicePixelRatio || 1, 2); // 最大2倍に制限

                        // ページの高さを事前に計算
                        const pageHeights = [];
                        let totalHeight = 0;

                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            const page = await pdf.getPage(pageNum);
                            const viewport = page.getViewport({ scale: baseScale });
                            const height = viewport.height;
                            pageHeights.push(height);
                            totalHeight += height + 20; // ギャップを含む
                        }

                        // 仮想スクロールコンテナの設定
                        container.style.height = totalHeight + 'px';
                        container.style.position = 'relative';

                        // ページプレースホルダーを作成
                        const pageElements = [];
                        let currentTop = 0;

                        for (let i = 0; i < pdf.numPages; i++) {
                            const placeholder = document.createElement('div');
                            placeholder.className = 'pdf-page-placeholder';
                            placeholder.style.position = 'absolute';
                            placeholder.style.top = currentTop + 'px';
                            placeholder.style.width = '100%';
                            placeholder.style.height = pageHeights[i] + 'px';
                            placeholder.style.display = 'flex';
                            placeholder.style.justifyContent = 'center';
                            placeholder.dataset.pageNum = i + 1;
                            container.appendChild(placeholder);
                            pageElements.push(placeholder);
                            currentTop += pageHeights[i] + 20;
                        }

                        // Intersection Observerでビューポート監視
                        const observer = new IntersectionObserver((entries) => {
                            entries.forEach(entry => {
                                const pageNum = parseInt(entry.target.dataset.pageNum);
                                if (entry.isIntersecting) {
                                    renderPageIfNeeded(pageNum, entry.target);
                                } else {
                                    unloadPageIfNeeded(pageNum, entry.target);
                                }
                            });
                        }, {
                            root: container.parentElement,
                            rootMargin: '50px' // 予備領域
                        });

                        pageElements.forEach(el => observer.value = observer);

                        // ページレンダリング関数
                        const renderPageIfNeeded = async (pageNum, placeholder) => {
                            if (placeholder.querySelector('canvas')) return; // 既にレンダリング済み

                            const page = await pdf.getPage(pageNum);
                            const viewport = page.getViewport({ scale: baseScale });

                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');

                            canvas.height = viewport.height * pixelRatio;
                            canvas.width = viewport.width * pixelRatio;
                            canvas.style.width = viewport.width + 'px';
                            canvas.style.height = viewport.height + 'px';
                            canvas.className = 'max-w-full h-auto';

                            context.scale(pixelRatio, pixelRatio);

                            placeholder.appendChild(canvas);

                            await page.render({
                                canvasContext: context,
                                viewport: viewport
                            }).promise;
                        };

                        // ページアンロード関数
                        const unloadPageIfNeeded = (pageNum, placeholder) => {
                            const canvas = placeholder.querySelector('canvas');
                            if (canvas) {
                                placeholder.removeChild(canvas);
                            }
                        };

                        // 初期レンダリング（ビューポート内のページ）
                        pageElements.forEach(el => observer.observe(el));

                    } catch (error) {
                        console.error('Error rendering PDF:', error);
                        alert('PDFの読み込みに失敗しました');
                        closePdf();
                    }
                };

                const handleFileChange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    revokeUrl();
                    pdfUrl.value = URL.createObjectURL(file);
                    currentView.value = 'pdf';
                    e.target.value = null;

                    await new Promise(resolve => setTimeout(resolve, 100));
                    await renderPdf(pdfUrl.value);
                };

                onUnmounted(() => {
                    closePdf();
                });

                return { currentView, pdfContainer, handleFileChange, closePdf };
            }
        }).mount('#app');
    </script>
</body>

</html>