<!DOCTYPE html>
<html lang="ja" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body class="m-0 p-0 font-sans antialiased bg-black text-white">
    <div id="app" class="min-h-screen">
        <div v-if="currentView === 'menu'" class="min-h-screen flex items-center justify-center bg-black">
            <input type="file" accept="application/pdf" @change="handleFileChange">
        </div>
        <div v-if="currentView === 'pdf'" class="min-h-screen bg-black">
            <button @click="closePdf"
                class="fixed top-4 right-4 z-50 bg-transparent backdrop-blur-sm hover:bg-black/20 text-white py-1 px-2 rounded-full shadow-lg hover:scale-110 transition-all flex items-center">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <div class="w-full h-screen overflow-y-auto">
                <div ref="pdfContainer" class="flex flex-col items-center gap-2 py-4"></div>
            </div>
        </div>
    </div>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const { createApp, ref, onUnmounted } = Vue;
        createApp({
            setup() {
                const currentView = ref('menu'), pdfUrl = ref(null), pdfContainer = ref(null), currentPdf = ref(null);
                const revokeUrl = () => pdfUrl.value && (URL.revokeObjectURL(pdfUrl.value), pdfUrl.value = null);
                const closePdf = () => {
                    pdfContainer.value && (pdfContainer.value.innerHTML = '');
                    currentPdf.value = null;
                    revokeUrl();
                    currentView.value = 'menu';
                };
                const renderPdf = async (url) => {
                    try {
                        const pdf = await pdfjsLib.getDocument(url).promise;
                        currentPdf.value = pdf;
                        const container = pdfContainer.value;
                        container.innerHTML = '';
                        const baseScale = 1.0, pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
                        const pageHeights = [], totalHeight = await (async () => {
                            let h = 0;
                            for (let i = 1; i <= pdf.numPages; i++) {
                                const p = await pdf.getPage(i), vh = p.getViewport({ scale: baseScale }).height;
                                pageHeights.push(vh);
                                h += vh + 10;
                            }
                            return h;
                        })();
                        container.style.cssText = `height:${totalHeight}px;position:relative;`;
                        const pageElements = [], currentTop = 0;
                        for (let i = 0; i < pdf.numPages; i++) {
                            const ph = document.createElement('div');
                            ph.className = 'pdf-page-placeholder';
                            ph.style.cssText = `position:absolute;top:${currentTop + i * (pageHeights[i] + 10)}px;width:100%;height:${pageHeights[i]}px;display:flex;justify-content:center;`;
                            ph.dataset.pageNum = i + 1;
                            container.appendChild(ph);
                            pageElements.push(ph);
                        }
                        const observer = new IntersectionObserver((entries) => entries.forEach(e => {
                            const pn = parseInt(e.target.dataset.pageNum);
                            e.isIntersecting ? renderPageIfNeeded(pn, e.target) : unloadPageIfNeeded(pn, e.target);
                        }), { root: container.parentElement, rootMargin: '50px' });
                        pageElements.forEach(el => observer.observe(el));
                        const renderPageIfNeeded = async (pn, ph) => {
                            if (ph.querySelector('canvas')) return;
                            const p = await pdf.getPage(pn), vp = p.getViewport({ scale: baseScale });
                            const c = document.createElement('canvas'), ctx = c.getContext('2d');
                            c.height = vp.height * pixelRatio;
                            c.width = vp.width * pixelRatio;
                            c.style.cssText = `width:${vp.width}px;height:${vp.height}px;max-width:100%;height:auto;`;
                            ctx.scale(pixelRatio, pixelRatio);
                            ph.appendChild(c);
                            await p.render({ canvasContext: ctx, viewport: vp }).promise;
                        };
                        const unloadPageIfNeeded = (pn, ph) => {
                            const c = ph.querySelector('canvas');
                            c && ph.removeChild(c);
                        };
                    } catch (error) {
                        console.error('Error rendering PDF:', error);
                        alert('PDFの読み込みに失敗しました');
                        closePdf();
                    }
                };
                const handleFileChange = async (e) => {
                    const f = e.target.files[0];
                    if (!f) return;
                    revokeUrl();
                    pdfUrl.value = URL.createObjectURL(f);
                    currentView.value = 'pdf';
                    e.target.value = null;
                    await new Promise(r => setTimeout(r, 100));
                    await renderPdf(pdfUrl.value);
                };
                onUnmounted(closePdf);
                return { currentView, pdfContainer, handleFileChange, closePdf };
            }
        }).mount('#app');
    </script>
</body>

</html>